import os
from typing import TypedDict, List, Dict
from langgraph.graph import StateGraph, END
import dotenv
from datetime import datetime
import uuid
import logging

dotenv.load_dotenv()

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TicketAgentState(TypedDict):
    """State for ticket agent"""
    messages: List[Dict]
    user_id: str
    user_role: str
    ticket_data: Dict
    response: str

class TicketManagementAgent:
    """Agent for handling ticket-related queries and actions"""
    
    def __init__(self, db_session):
        """Initialize with database session - NO API CALLS"""
        self.db = db_session
        logger.info("TicketManagementAgent initialized")
        
        try:
            from langchain_openai import AzureChatOpenAI
            self.llm = AzureChatOpenAI(
                azure_deployment=os.getenv("AZURE_DEPLOYMENT"),
                api_version=os.getenv("AZURE_API_VERSION", "2024-02-15-preview"),
                temperature=0,
                azure_endpoint=os.getenv("AZURE_ENDPOINT"),
                api_key=os.getenv("AZURE_API_KEY")
            )
        except Exception as e:
            logger.warning(f"LLM initialization failed: {e}")
            self.llm = None
        
        self.graph = self._build_graph()
    
    def create_ticket_tool(self, category: str, description: str, priority: str, user_id: str) -> Dict:
        """Create a new ticket - DIRECT DB ACCESS"""
        try:
            logger.info(f"Creating ticket for user: {user_id}")
            from src.database.models import Ticket
            
            # Generate unique ticket ID
            ticket_id = f"TKT-{str(uuid.uuid4())[:8].upper()}"
            
            # ‚úÖ FIX: Create ticket with ALL required fields
            new_ticket = Ticket(
                # id will be auto-generated by database (Integer primary key)
                ticket_id=ticket_id,
                user_id=user_id,
                category=category,
                description=description,
                priority=priority,
                status="Open",
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow(),
                last_action_at=datetime.utcnow(),  # ‚úÖ Added
                escalated=False,  # ‚úÖ Added
                escalation_level=0,  # ‚úÖ Added
                assigned_to=None,  # ‚úÖ Added
                resolved_at=None,  # ‚úÖ Added
                resolution_notes=None  # ‚úÖ Added
            )
            
            self.db.add(new_ticket)
            self.db.commit()
            self.db.refresh(new_ticket)
            
            logger.info(f"Ticket created successfully: {ticket_id}")
            
            return {
                "success": True,
                "ticket_id": new_ticket.ticket_id,
                "status": new_ticket.status,
                "priority": new_ticket.priority,
                "category": new_ticket.category,
                "description": new_ticket.description,
                "created_at": new_ticket.created_at.isoformat() if new_ticket.created_at else "",
                "message": f"Ticket {new_ticket.ticket_id} created successfully"
            }
            
        except Exception as e:
            logger.error(f"Error creating ticket: {str(e)}", exc_info=True)
            self.db.rollback()
            return {"success": False, "error": f"Database error: {str(e)}"}
    
    def get_my_tickets_tool(self, user_id: str, status: str = None) -> Dict:
        """Get user tickets - DIRECT DB ACCESS"""
        try:
            logger.info(f"Getting tickets for user: {user_id}, status: {status}")
            from src.database.models import Ticket
            
            query = self.db.query(Ticket).filter(Ticket.user_id == user_id)
            
            if status:
                query = query.filter(Ticket.status == status)
            
            tickets = query.order_by(Ticket.created_at.desc()).all()
            logger.info(f"Found {len(tickets)} tickets for user {user_id}")
            
            ticket_list = [
                {
                    "ticket_id": t.ticket_id,
                    "status": t.status,
                    "priority": t.priority,
                    "description": t.description,
                    "category": t.category,
                    "created_at": t.created_at.isoformat() if t.created_at else "",
                    "updated_at": t.updated_at.isoformat() if t.updated_at else ""
                }
                for t in tickets
            ]
            
            return {
                "success": True,
                "total": len(ticket_list),
                "tickets": ticket_list,
                "summary": f"Found {len(ticket_list)} tickets"
            }
            
        except Exception as e:
            logger.error(f"Error getting user tickets: {str(e)}", exc_info=True)
            return {"success": False, "error": f"Database error: {str(e)}"}
    
    def get_all_tickets_tool(self, status: str = None, priority: str = None) -> Dict:
        """Get all tickets - DIRECT DB ACCESS (Admin only)"""
        try:
            logger.info(f"Getting all tickets - status: {status}, priority: {priority}")
            from src.database.models import Ticket
            
            query = self.db.query(Ticket)
            
            if status:
                query = query.filter(Ticket.status == status)
            if priority:
                query = query.filter(Ticket.priority == priority)
            
            tickets = query.order_by(Ticket.created_at.desc()).all()
            logger.info(f"Found {len(tickets)} total tickets in system")
            
            ticket_list = [
                {
                    "ticket_id": t.ticket_id,
                    "user_id": t.user_id,
                    "status": t.status,
                    "priority": t.priority,
                    "description": t.description,
                    "category": t.category,
                    "created_at": t.created_at.isoformat() if t.created_at else "",
                    "updated_at": t.updated_at.isoformat() if t.updated_at else ""
                }
                for t in tickets
            ]
            
            return {
                "success": True,
                "total": len(ticket_list),
                "tickets": ticket_list,
                "summary": f"Found {len(ticket_list)} tickets in system"
            }
            
        except Exception as e:
            logger.error(f"Error getting all tickets: {str(e)}", exc_info=True)
            return {"success": False, "error": f"Database error: {str(e)}"}
    
    def get_ticket_stats_tool(self) -> Dict:
        """Get ticket stats - DIRECT DB ACCESS"""
        try:
            logger.info("Getting ticket statistics")
            from src.database.models import Ticket
            from sqlalchemy import func
            
            total = self.db.query(func.count(Ticket.id)).scalar() or 0
            open_count = self.db.query(func.count(Ticket.id)).filter(Ticket.status == "Open").scalar() or 0
            in_progress = self.db.query(func.count(Ticket.id)).filter(Ticket.status == "In Progress").scalar() or 0
            escalated = self.db.query(func.count(Ticket.id)).filter(Ticket.status == "Escalated").scalar() or 0
            resolved = self.db.query(func.count(Ticket.id)).filter(Ticket.status == "Resolved").scalar() or 0
            
            resolution_rate = (resolved / total * 100) if total > 0 else 0
            
            stats = {
                "total_tickets": total,
                "open": open_count,
                "in_progress": in_progress,
                "escalated": escalated,
                "resolved": resolved,
                "resolution_rate": round(resolution_rate, 2)
            }
            
            logger.info(f"Stats: {stats}")
            
            return {
                "success": True,
                "stats": stats,
                "summary": f"Total: {total}, Open: {open_count}, Escalated: {escalated}"
            }
            
        except Exception as e:
            logger.error(f"Error getting stats: {str(e)}", exc_info=True)
            return {"success": False, "error": f"Database error: {str(e)}"}
    
    def _build_graph(self) -> StateGraph:
        """Build the LangGraph workflow"""
        workflow = StateGraph(TicketAgentState)
        
        workflow.add_node("understand_intent", self.understand_intent)
        workflow.add_node("execute_action", self.execute_action)
        workflow.add_node("format_response", self.format_response)
        
        workflow.set_entry_point("understand_intent")
        workflow.add_edge("understand_intent", "execute_action")
        workflow.add_edge("execute_action", "format_response")
        workflow.add_edge("format_response", END)
        
        return workflow.compile()
    
    def understand_intent(self, state: TicketAgentState) -> TicketAgentState:
        """Understand user's intent with improved description extraction"""
        last_message = state["messages"][-1]["content"].lower()
        original_message = state["messages"][-1]["content"]
        user_role = state.get("user_role", "user")
        user_id = state.get("user_id", "")
        
        logger.info(f"Understanding intent for message: '{last_message[:50]}...'")
        
        action = None
        parameters = {}
        
        # Create ticket
        if "create" in last_message and "ticket" in last_message:
            action = "create_ticket"
            parameters["user_id"] = user_id
            
            # Extract priority
            if "high" in last_message or "urgent" in last_message:
                parameters["priority"] = "High"
            elif "critical" in last_message:
                parameters["priority"] = "Critical"
            elif "low" in last_message:
                parameters["priority"] = "Low"
            else:
                parameters["priority"] = "Medium"
            
            # Extract category
            if "maintenance" in last_message or "repair" in last_message:
                parameters["category"] = "Maintenance"
            elif "it" in last_message or "computer" in last_message or "laptop" in last_message:
                parameters["category"] = "IT Support"
            elif "cleaning" in last_message or "housekeeping" in last_message:
                parameters["category"] = "Housekeeping"
            elif "security" in last_message:
                parameters["category"] = "Security"
            else:
                parameters["category"] = "General"
            
            # Improved description extraction
            description = original_message
            
            patterns_to_remove = [
                "create a ticket for ",
                "create ticket for ",
                "create a high priority maintenance ticket for ",
                "create a high priority ticket for ",
                "create a low priority ticket for ",
                "create a medium priority ticket for ",
                "create a critical ticket for ",
                "create an urgent ticket for ",
                "create a maintenance ticket for ",
                "create an it ticket for ",
                "create a cleaning ticket for ",
                "create a security ticket for ",
                "create high priority ticket for ",
                "create low priority ticket for ",
                "create medium priority ticket for ",
                "create a ",
                "create ",
            ]
            
            patterns_to_remove.sort(key=len, reverse=True)
            for pattern in patterns_to_remove:
                if description.lower().startswith(pattern):
                    description = description[len(pattern):].strip()
                    break
            
            if description and description[0].islower():
                description = description[0].upper() + description[1:]
            
            parameters["description"] = description
            logger.info(f"Extracted description: '{description}'")
        
        # My tickets
        elif "my tickets" in last_message or "my ticket" in last_message:
            action = "get_my_tickets"
            parameters["user_id"] = user_id
            
            if "open" in last_message:
                parameters["status"] = "Open"
            elif "resolved" in last_message:
                parameters["status"] = "Resolved"
            elif "escalated" in last_message:
                parameters["status"] = "Escalated"
            elif "in progress" in last_message:
                parameters["status"] = "In Progress"
        
        # All tickets
        elif ("all tickets" in last_message or "show tickets" in last_message or "display" in last_message or "tickets" in last_message):
            if user_role == "admin":
                action = "get_all_tickets"
                
                if "open" in last_message and "tickets" in last_message:
                    parameters["status"] = "Open"
                elif "escalated" in last_message:
                    parameters["status"] = "Escalated"
                elif "resolved" in last_message:
                    parameters["status"] = "Resolved"
                elif "in progress" in last_message:
                    parameters["status"] = "In Progress"
                
                if "high priority" in last_message:
                    parameters["priority"] = "High"
                elif "critical" in last_message:
                    parameters["priority"] = "Critical"
            else:
                action = "get_my_tickets"
                parameters["user_id"] = user_id
        
        # Statistics
        elif "stats" in last_message or "statistics" in last_message:
            action = "get_ticket_stats"
        
        # Default
        else:
            action = "get_my_tickets"
            parameters["user_id"] = user_id
        
        logger.info(f"Action: {action}, Parameters: {parameters}")
        
        state["ticket_data"] = {
            "action": action,
            "parameters": parameters
        }
        
        return state
    
    def execute_action(self, state: TicketAgentState) -> TicketAgentState:
        """Execute the determined action"""
        action = state["ticket_data"].get("action")
        params = state["ticket_data"].get("parameters", {})
        
        logger.info(f"Executing action: {action}")
        
        try:
            if action == "create_ticket":
                result = self.create_ticket_tool(**params)
            elif action == "get_my_tickets":
                result = self.get_my_tickets_tool(**params)
            elif action == "get_all_tickets":
                result = self.get_all_tickets_tool(**params)
            elif action == "get_ticket_stats":
                result = self.get_ticket_stats_tool()
            else:
                result = {"success": False, "error": "Unknown action"}
            
            state["ticket_data"]["result"] = result
            
        except Exception as e:
            logger.error(f"Error executing action: {str(e)}", exc_info=True)
            state["ticket_data"]["result"] = {"success": False, "error": str(e)}
        
        return state
    
    def format_response(self, state: TicketAgentState) -> TicketAgentState:
        """Format the response with clean markdown - NO HTML"""
        result = state["ticket_data"].get("result", {})
        user_role = state.get("user_role", "user")
        
        logger.info(f"Formatting response for role: {user_role}")
        
        try:
            if result.get("success"):
                if "tickets" in result:
                    tickets = result["tickets"]
                    total = result['total']
                    
                    if user_role == "admin":
                        response = "üîß **Admin View - System Tickets**\n\n"
                        response += f"‚úÖ Found **{total}** ticket{'s' if total != 1 else ''} in the system\n\n"
                    else:
                        response = "üìã **Your Tickets**\n\n"
                        response += f"‚úÖ Found **{total}** ticket{'s' if total != 1 else ''}\n\n"
                    
                    if total == 0:
                        response += "No tickets found matching your criteria."
                    else:
                        response += "---\n\n"
                        
                        for idx, ticket in enumerate(tickets[:15], 1):
                            created = ticket.get('created_at', 'Unknown')
                            if created and created != 'Unknown':
                                try:
                                    dt = datetime.fromisoformat(created)
                                    created = dt.strftime("%b %d, %Y at %I:%M %p")
                                except:
                                    pass
                            
                            updated = ticket.get('updated_at', '')
                            updated_text = ''
                            if updated:
                                try:
                                    dt = datetime.fromisoformat(updated)
                                    updated = dt.strftime("%b %d, %Y at %I:%M %p")
                                    updated_text = f"- üîÑ **Last Updated:** {updated}\n"
                                except:
                                    pass
                            
                            response += f"### {idx}. Ticket {ticket['ticket_id']}\n\n"
                            
                            if user_role == "admin" and 'user_id' in ticket:
                                response += f"- üë§ **User:** {ticket['user_id']}\n"
                            
                            response += f"- üìä **Status:** {ticket['status']}\n"
                            response += f"- ‚ö° **Priority:** {ticket['priority']}\n"
                            response += f"- üìÅ **Category:** {ticket.get('category', 'N/A')}\n"
                            response += f"- üìù **Description:** {ticket['description']}\n"
                            response += f"- üïí **Created:** {created}\n"
                            response += updated_text
                            response += "\n---\n\n"
                        
                        if total > 15:
                            response += f"\nüìÑ _Showing 15 of {total} tickets. {total - 15} more not displayed._"
                
                elif "ticket_id" in result:
                    created = result.get('created_at', '')
                    created_display = 'Just now'
                    if created:
                        try:
                            dt = datetime.fromisoformat(created)
                            created_display = dt.strftime("%b %d, %Y at %I:%M %p")
                        except:
                            pass
                    
                    response = "‚úÖ **Ticket Created Successfully!**\n\n"
                    response += "---\n\n"
                    response += f"### üé´ Ticket: {result['ticket_id']}\n\n"
                    response += f"- üìä **Status:** {result['status']}\n"
                    response += f"- ‚ö° **Priority:** {result['priority']}\n"
                    response += f"- üìÅ **Category:** {result.get('category', 'N/A')}\n"
                    response += f"- üìù **Description:** {result.get('description', 'N/A')}\n"
                    response += f"- üïí **Created:** {created_display}\n"
                    response += "\n---\n\n"
                    response += "üí° _You can view your ticket anytime using: **'Show my tickets'**_"
                
                elif "stats" in result:
                    stats = result["stats"]
                    response = "üìä **Ticket Statistics Dashboard**\n\n"
                    response += "---\n\n"
                    response += "### üìà Overall Metrics\n\n"
                    response += f"- **Total Tickets:** {stats['total_tickets']}\n\n"
                    response += "### üìã By Status\n\n"
                    response += f"- üü¢ **Open:** {stats['open']}\n"
                    response += f"- üîµ **In Progress:** {stats['in_progress']}\n"
                    response += f"- üî¥ **Escalated:** {stats['escalated']}\n"
                    response += f"- ‚úÖ **Resolved:** {stats['resolved']}\n\n"
                    response += "### üìä Performance\n\n"
                    response += f"- **Resolution Rate:** {stats['resolution_rate']}%\n"
                    response += "\n---"
                else:
                    response = result.get("summary", "‚úÖ Action completed successfully")
            else:
                response = f"‚ùå **Error:** {result.get('error', 'Unknown error occurred')}"
            
            state["response"] = response
            
        except Exception as e:
            logger.error(f"Error formatting response: {str(e)}", exc_info=True)
            state["response"] = f"‚ùå Error formatting response: {str(e)}"
        
        return state
    
    def process_message(self, message: str, user_id: str, user_role: str = "user") -> str:
        """Process a user message"""
        initial_state = {
            "messages": [{"role": "user", "content": message}],
            "user_id": user_id,
            "user_role": user_role,
            "ticket_data": {},
            "response": ""
        }
        
        try:
            logger.info(f"Processing message for user {user_id} (role: {user_role})")
            final_state = self.graph.invoke(initial_state)
            return final_state["response"]
        except Exception as e:
            logger.error(f"Error in process_message: {str(e)}", exc_info=True)
            return f"‚ùå Error processing request: {str(e)}"
